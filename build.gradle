plugins {
    id 'java'
    id 'application'
    alias(libs.plugins.launch4j)
    alias(libs.plugins.shadow)

    // Static analysis
    id 'com.github.spotbugs' version '6.0.26'
}

dependencyLocking {
    lockAllConfigurations()
}

ext {
    // Define osgi.platform for SWT dependency resolution
    setProperty('osgi.platform', 'win32.win32.x86_64')
}

group = 'org.tvrenamer'
version = '1.0.0-SNAPSHOT'

java {
    toolchain {
        // Build with Java 21.
        languageVersion = JavaLanguageVersion.of(21)
    }
}

// Keep runtime compatibility at Java 17+ even when building with JDK 21.
tasks.withType(JavaCompile).configureEach {
    options.release = 17
}

spotbugs {
    // Keep this conservative to start with. We can ratchet up later.
    //
    // Note: SpotBugs returns a non-zero exit code when it finds bugs, even if Gradle is
    // configured to ignore failures. We keep this non-blocking for now.
    ignoreFailures = true
    showProgress = true

    // SpotBugs Gradle plugin expects enum values (not strings) for these.
    effort = com.github.spotbugs.snom.Effort.DEFAULT
    reportLevel = com.github.spotbugs.snom.Confidence.valueOf('LOW')
}

// Run SpotBugs only for main sources by default (developers can run test analysis explicitly).
// Run SpotBugs only for main sources by default (developers can run test analysis explicitly).
// Some projects may not define SpotBugs tasks for custom test source sets, so guard with findByName.
def spotbugsTestTask = tasks.findByName('spotbugsTest')
if (spotbugsTestTask != null) {
    spotbugsTestTask.enabled = false
}
def spotbugsIntegrationTestTask = tasks.findByName('spotbugsIntegrationTest')
if (spotbugsIntegrationTestTask != null) {
    spotbugsIntegrationTestTask.enabled = false
}

tasks.named('spotbugsMain') {
    reports {
        html.required = true
        xml.required = false
    }
}

repositories {
    mavenCentral()
}

dependencies {
    // SWT - using platform specific dependency for Windows build
    // Exclude transitive dependencies to prevent resolution of '${osgi.platform}'
    implementation(libs.swtWin64) {
        transitive = false
    }

    // Core dependencies - modernized
    implementation(libs.xstream)
    implementation(libs.commonsCodec)
    // xmlpull is provided transitively via xstream -> mxparser -> xmlpull

    // Networking
    implementation(libs.okhttp)

    // Testing
    testImplementation(libs.junit4)
}

application {
    mainClass = 'org.tvrenamer.controller.Launcher'
    // Default JVM args if needed
    // applicationDefaultJvmArgs = []
}

// Build metadata generated at build time.
// - tvrenamer.version: 1.0.<buildNumber>, where buildNumber is:
//     - GitHub Actions run number when available (monotonically increasing per workflow), else
//     - git commit count (best-effort).
// - tvrenamer.builddate: YYMMDD (UTC)
// - tvrenamer.commit: full git SHA (or "unknown")
def computeBuildNumber = {
    // Use git commit count everywhere (including CI) for consistent versioning:
    // - App/JAR embeds 1.0.<commitCount> in /tvrenamer.version
    // - EXE embeds 1.0.<commitCount>.0 in Windows metadata
    //
    // IMPORTANT: CI must use a full git history (fetch-depth: 0) or commit counts may be incorrect.
    try {
        def proc = ["git", "rev-list", "--count", "HEAD"].execute(null, project.rootDir)
        proc.waitFor()
        if (proc.exitValue() == 0) {
            return proc.in.text.trim()
        }
    } catch (Exception ignored) {
        // Fall through to default below
    }
    return "0"
}

// Ensure Launch4j's EXE metadata version matches the app version scheme.
// - App/JAR version is generated into /tvrenamer.version as: 1.0.<buildNumber>
// - Launch4j expects a numeric dotted version; use: 1.0.<buildNumber>.0
def computedBuildNumber = computeBuildNumber()
def computedExeVersion = "1.0.${computedBuildNumber}.0"

launch4j {
    mainClassName = 'org.tvrenamer.controller.Launcher'
    icon = "${projectDir}/src/main/resources/icons/oldschool-tv-icon.ico"
    jarTask = tasks.shadowJar
    outfile = "TVRenamer.exe"
    downloadUrl = "http://java.com/download"
    headerType = "gui"
    requires64Bit = true
    jreMinVersion = "17"

    // Launch4j plugin supports these version metadata fields via `version` and `textVersion`.
    // Keep them aligned with the build number used for /tvrenamer.version.
    version = computedExeVersion
    textVersion = computedExeVersion
}

def computeCommitSha = {
    try {
        def proc = ["git", "rev-parse", "HEAD"].execute(null, project.rootDir)
        proc.waitFor()
        if (proc.exitValue() == 0) {
            return proc.in.text.trim()
        }
    } catch (Exception ignored) {
        // Fall through to default below
    }
    return "unknown"
}

def computeBuildDateYYMMDDUtc = {
    try {
        def tz = java.util.TimeZone.getTimeZone("UTC")
        def df = new java.text.SimpleDateFormat("yyMMdd")
        df.setTimeZone(tz)
        return df.format(new Date())
    } catch (Exception ignored) {
        // Fall through to default below
    }
    return "000000"
}

tasks.register('generateBuildMetadataFiles') {
    outputs.file(layout.buildDirectory.file("generated/version/tvrenamer.version"))
    outputs.file(layout.buildDirectory.file("generated/version/tvrenamer.builddate"))
    outputs.file(layout.buildDirectory.file("generated/version/tvrenamer.commit"))
    doLast {
        def buildNumber = computeBuildNumber()
        def sha = computeCommitSha()
        def builtOn = computeBuildDateYYMMDDUtc()

        def outDir = layout.buildDirectory.dir("generated/version").get().asFile
        outDir.mkdirs()

        new File(outDir, "tvrenamer.version").text = "1.0.${buildNumber}\n"
        new File(outDir, "tvrenamer.builddate").text = "${builtOn}\n"
        new File(outDir, "tvrenamer.commit").text = "${sha}\n"
    }
}

def generatedVersionFile = layout.buildDirectory.file("generated/version/tvrenamer.version")
def generatedBuildDateFile = layout.buildDirectory.file("generated/version/tvrenamer.builddate")
def generatedCommitFile = layout.buildDirectory.file("generated/version/tvrenamer.commit")

tasks.named('processResources') {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    // Ensure generated build metadata replaces any static resources.
    exclude("tvrenamer.version")
    exclude("tvrenamer.builddate")
    exclude("tvrenamer.commit")

    dependsOn(tasks.named('generateBuildMetadataFiles'))

    // Add the generated metadata files into the root of the resources output.
    from(generatedVersionFile) {
        into ""
        rename { "tvrenamer.version" }
    }
    from(generatedBuildDateFile) {
        into ""
        rename { "tvrenamer.builddate" }
    }
    from(generatedCommitFile) {
        into ""
        rename { "tvrenamer.commit" }
    }

    // Workaround: ensure the files are present in build/resources/main even if Gradle's
    // CopySpec input isn't picked up as expected on some environments.
    doLast {
        copy {
            from(generatedVersionFile)
            from(generatedBuildDateFile)
            from(generatedCommitFile)
            into(layout.buildDirectory.dir("resources/main").get().asFile)
        }
    }
}

tasks.named('processTestResources') {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    // Tests also need build metadata on the classpath to avoid static init failures.
    // Ensure we use the generated metadata and do not rely on any source files.
    exclude("tvrenamer.version")
    exclude("tvrenamer.builddate")
    exclude("tvrenamer.commit")

    dependsOn(tasks.named('generateBuildMetadataFiles'))

    from(generatedVersionFile) {
        into ""
        rename { "tvrenamer.version" }
    }
    from(generatedBuildDateFile) {
        into ""
        rename { "tvrenamer.builddate" }
    }
    from(generatedCommitFile) {
        into ""
        rename { "tvrenamer.commit" }
    }

    // Workaround: ensure the files are present in build/resources/test even if Gradle's
    // CopySpec input isn't picked up as expected on some environments.
    doLast {
        copy {
            from(generatedVersionFile)
            from(generatedBuildDateFile)
            from(generatedCommitFile)
            into(layout.buildDirectory.dir("resources/test").get().asFile)
        }
    }
}

// Shadow plugin configuration for integrated JAR with all dependencies
shadowJar {
    // Produce a stable artifact name for easier manual testing/scripts.
    // We keep the integrated "fat jar" behavior, but avoid version/classifier in the filename.
    archiveFileName.set("tvrenamer.jar")

    // Keep merge behavior for service files.
    mergeServiceFiles()

    dependsOn(tasks.named('generateBuildMetadataFiles'))

    // Force the generated build metadata files into the JAR root.
    from(layout.buildDirectory.file("generated/version/tvrenamer.version")) {
        into ""
        rename { "tvrenamer.version" }
    }
    from(layout.buildDirectory.file("generated/version/tvrenamer.builddate")) {
        into ""
        rename { "tvrenamer.builddate" }
    }
    from(layout.buildDirectory.file("generated/version/tvrenamer.commit")) {
        into ""
        rename { "tvrenamer.commit" }
    }
}

// Also produce a versioned copy of the fat jar for releases/users who want side-by-side versions.
tasks.register('shadowJarVersioned', com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar) {
    group = 'build'
    description = 'Build a versioned fat jar alongside tvrenamer.jar.'

    // Match shadowJar behavior.
    from(sourceSets.main.output)
    configurations = [project.configurations.runtimeClasspath]
    mergeServiceFiles()

    dependsOn(tasks.named('generateBuildMetadataFiles'))

    from(layout.buildDirectory.file("generated/version/tvrenamer.version")) {
        into ""
        rename { "tvrenamer.version" }
    }
    from(layout.buildDirectory.file("generated/version/tvrenamer.builddate")) {
        into ""
        rename { "tvrenamer.builddate" }
    }
    from(layout.buildDirectory.file("generated/version/tvrenamer.commit")) {
        into ""
        rename { "tvrenamer.commit" }
    }

    // Versioned filename uses the embedded version scheme (1.0.<commitCount>).
    archiveFileName.set("tvrenamer-${computeBuildNumber()}.jar")
    destinationDirectory.set(layout.buildDirectory.dir("libs"))
}

// Ensure `build` produces both jars.
tasks.named('build') {
    dependsOn(tasks.named('shadowJarVersioned'))
}

sourceSets {
    main {
        java {
            srcDir 'src/main/java'
        }
        resources {
            srcDir 'src/main/resources'
        }
    }
    test {
        java {
            srcDir 'src/test/java'
            exclude 'org/tvrenamer/controller/TheTVDBProviderTest.java'
        }
        resources {
            srcDir 'src/test/resources'
        }
    }
    // Integration tests (TVDB / network-dependent). Not run as part of the standard 'test' task.
    integrationTest {
        java {
            // Reuse the same test sources, but only include the TVDB integration test.
            srcDir 'src/test/java'
            include 'org/tvrenamer/controller/TheTVDBProviderTest.java'
        }
        resources {
            srcDir 'src/test/resources'
        }

        // IMPORTANT: include the normal test outputs (e.g., EpisodeTestData) on the integration test classpath.
        compileClasspath += sourceSets.main.output + sourceSets.test.output + configurations.testRuntimeClasspath
        runtimeClasspath += output + compileClasspath
    }
}

configurations {
    integrationTestImplementation.extendsFrom(testImplementation)
    integrationTestRuntimeOnly.extendsFrom(testRuntimeOnly)
}

tasks.register('integrationTest', Test) {
    description = 'Runs network-dependent integration tests (TVDB).'
    group = 'verification'
    testClassesDirs = sourceSets.integrationTest.output.classesDirs
    classpath = sourceSets.integrationTest.runtimeClasspath
    shouldRunAfter(tasks.named('test'))
}

tasks.named('check') {
    dependsOn(tasks.named('test'))
    // integrationTest is opt-in; do not depend on it by default.
}

tasks.named('jar') {
    enabled = false
}

tasks.named('createExe') {
    dependsOn(tasks.named('shadowJar'))
}
