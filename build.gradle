plugins {
    id 'java'
    id 'application'
    alias(libs.plugins.launch4j)
    alias(libs.plugins.shadow)
}

dependencyLocking {
    lockAllConfigurations()
}

ext {
    // Define osgi.platform for SWT dependency resolution
    setProperty('osgi.platform', 'win32.win32.x86_64')
}

group = 'org.tvrenamer'
version = '1.0.0-SNAPSHOT'

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(17)
    }
}

repositories {
    mavenCentral()
}

dependencies {
    // SWT - using platform specific dependency for Windows build
    // Exclude transitive dependencies to prevent resolution of '${osgi.platform}'
    implementation(libs.swtWin64) {
        transitive = false
    }

    // Core dependencies - modernized
    implementation(libs.xstream)
    implementation(libs.commonsCodec)
    // xmlpull is provided transitively via xstream -> mxparser -> xmlpull

    // Networking
    implementation(libs.okhttp)

    // Testing
    testImplementation(libs.junit4)
}

application {
    mainClass = 'org.tvrenamer.controller.Launcher'
    // Default JVM args if needed
    // applicationDefaultJvmArgs = []
}

launch4j {
    mainClassName = 'org.tvrenamer.controller.Launcher'
    icon = "${projectDir}/src/main/resources/icons/oldschool-tv-icon.ico"
    jarTask = tasks.shadowJar
    outfile = "TVRenamer.exe"
    downloadUrl = "http://java.com/download"
    headerType = "gui"
    requires64Bit = true
    jreMinVersion = "17"
}

// Generate tvrenamer.version at build time from Git commit count.
// Version format: 1.0.<commitCount>
def computeCommitCount = {
    try {
        def proc = ["git", "rev-list", "--count", "HEAD"].execute(null, project.rootDir)
        proc.waitFor()
        if (proc.exitValue() == 0) {
            return proc.in.text.trim()
        }
    } catch (Exception ignored) {
        // Fall through to default below
    }
    return "0"
}

tasks.register('generateVersionFile') {
    outputs.file(layout.buildDirectory.file("generated/version/tvrenamer.version"))
    doLast {
        def count = computeCommitCount()
        def versionText = "1.0.${count}\n"
        def outFile = layout.buildDirectory.file("generated/version/tvrenamer.version").get().asFile
        outFile.parentFile.mkdirs()
        outFile.text = versionText
    }
}

def generatedVersionFile = layout.buildDirectory.file("generated/version/tvrenamer.version")

tasks.named('processResources') {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    // Ensure the generated version file replaces the static resource version.
    exclude("tvrenamer.version")

    dependsOn(tasks.named('generateVersionFile'))

    // Add the generated version file into the root of the resources output.
    from(generatedVersionFile) {
        into ""
        rename { "tvrenamer.version" }
    }

    // Workaround: ensure the version file is present in build/resources/main even if Gradle's
    // CopySpec input isn't picked up as expected on some environments.
    doLast {
        copy {
            from(generatedVersionFile)
            into(layout.buildDirectory.dir("resources/main").get().asFile)
            rename { "tvrenamer.version" }
        }
    }
}

tasks.named('processTestResources') {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    // Tests also need a tvrenamer.version on the classpath to avoid static init failures.
    // Ensure we use the generated version and do not rely on the source file.
    exclude("tvrenamer.version")

    dependsOn(tasks.named('generateVersionFile'))

    from(generatedVersionFile) {
        into ""
        rename { "tvrenamer.version" }
    }

    // Workaround: ensure the version file is present in build/resources/test even if Gradle's
    // CopySpec input isn't picked up as expected on some environments.
    doLast {
        copy {
            from(generatedVersionFile)
            into(layout.buildDirectory.dir("resources/test").get().asFile)
            rename { "tvrenamer.version" }
        }
    }
}

// Shadow plugin configuration for integrated JAR with all dependencies
shadowJar {
    // Keep the default classifier (typically "-all") stable so consumers
    // and CI artifact paths donâ€™t accidentally break.
    archiveClassifier.set('all')
    mergeServiceFiles()

    dependsOn(tasks.named('generateVersionFile'))

    // Force the generated version file into the JAR root.
    from(layout.buildDirectory.file("generated/version/tvrenamer.version")) {
        into ""
        rename { "tvrenamer.version" }
    }
}

sourceSets {
    main {
        java {
            srcDir 'src/main/java'
        }
        resources {
            srcDir 'src/main/resources'
        }
    }
    test {
        java {
            srcDir 'src/test/java'
            exclude 'org/tvrenamer/controller/TheTVDBProviderTest.java'
        }
        resources {
            srcDir 'src/test/resources'
        }
    }
    // Integration tests (TVDB / network-dependent). Not run as part of the standard 'test' task.
    integrationTest {
        java {
            // Reuse the same test sources, but only include the TVDB integration test.
            srcDir 'src/test/java'
            include 'org/tvrenamer/controller/TheTVDBProviderTest.java'
        }
        resources {
            srcDir 'src/test/resources'
        }

        // IMPORTANT: include the normal test outputs (e.g., EpisodeTestData) on the integration test classpath.
        compileClasspath += sourceSets.main.output + sourceSets.test.output + configurations.testRuntimeClasspath
        runtimeClasspath += output + compileClasspath
    }
}

configurations {
    integrationTestImplementation.extendsFrom(testImplementation)
    integrationTestRuntimeOnly.extendsFrom(testRuntimeOnly)
}

tasks.register('integrationTest', Test) {
    description = 'Runs network-dependent integration tests (TVDB).'
    group = 'verification'
    testClassesDirs = sourceSets.integrationTest.output.classesDirs
    classpath = sourceSets.integrationTest.runtimeClasspath
    shouldRunAfter(tasks.named('test'))
}

tasks.named('check') {
    dependsOn(tasks.named('test'))
    // integrationTest is opt-in; do not depend on it by default.
}

tasks.named('jar') {
    enabled = false
}

tasks.named('createExe') {
    dependsOn(tasks.named('shadowJar'))
}
