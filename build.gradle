plugins {
    id 'java'
    id 'application'
    alias(libs.plugins.launch4j)
    alias(libs.plugins.shadow)
}

dependencyLocking {
    lockAllConfigurations()
}

ext {
    // Define osgi.platform for SWT dependency resolution
    setProperty('osgi.platform', 'win32.win32.x86_64')
}

group = 'org.tvrenamer'
version = '1.0.0-SNAPSHOT'

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(17)
    }
}

repositories {
    mavenCentral()
}

dependencies {
    // SWT - using platform specific dependency for Windows build
    // Exclude transitive dependencies to prevent resolution of '${osgi.platform}'
    implementation(libs.swtWin64) {
        transitive = false
    }

    // Core dependencies - modernized
    implementation(libs.xstream)
    implementation(libs.commonsCodec)
    // xmlpull is provided transitively via xstream -> mxparser -> xmlpull

    // Networking
    implementation(libs.okhttp)

    // Testing
    testImplementation(libs.junit4)
}

application {
    mainClass = 'org.tvrenamer.controller.Launcher'
    // Default JVM args if needed
    // applicationDefaultJvmArgs = []
}

launch4j {
    mainClassName = 'org.tvrenamer.controller.Launcher'
    icon = "${projectDir}/src/main/resources/icons/oldschool-tv-icon.ico"
    jarTask = tasks.shadowJar
    outfile = "TVRenamer.exe"
    downloadUrl = "http://java.com/download"
    headerType = "gui"
    requires64Bit = true
    jreMinVersion = "17"
}

// Build metadata generated at build time.
// - tvrenamer.version: 1.0.<buildNumber>, where buildNumber is:
//     - GitHub Actions run number when available (monotonically increasing per workflow), else
//     - git commit count (best-effort).
// - tvrenamer.builddate: YYMMDD (UTC)
// - tvrenamer.commit: full git SHA (or "unknown")
def computeBuildNumber = {
    // Prefer GitHub Actions run number when available.
    // This avoids shallow-clone / history differences and is naturally monotonic in CI.
    def ghaRunNumber = System.getenv("GITHUB_RUN_NUMBER")
    if (ghaRunNumber != null && ghaRunNumber.trim()) {
        return ghaRunNumber.trim()
    }

    // Fallback: git commit count
    try {
        def proc = ["git", "rev-list", "--count", "HEAD"].execute(null, project.rootDir)
        proc.waitFor()
        if (proc.exitValue() == 0) {
            return proc.in.text.trim()
        }
    } catch (Exception ignored) {
        // Fall through to default below
    }
    return "0"
}

def computeCommitSha = {
    try {
        def proc = ["git", "rev-parse", "HEAD"].execute(null, project.rootDir)
        proc.waitFor()
        if (proc.exitValue() == 0) {
            return proc.in.text.trim()
        }
    } catch (Exception ignored) {
        // Fall through to default below
    }
    return "unknown"
}

def computeBuildDateYYMMDDUtc = {
    try {
        def tz = java.util.TimeZone.getTimeZone("UTC")
        def df = new java.text.SimpleDateFormat("yyMMdd")
        df.setTimeZone(tz)
        return df.format(new Date())
    } catch (Exception ignored) {
        // Fall through to default below
    }
    return "000000"
}

tasks.register('generateBuildMetadataFiles') {
    outputs.file(layout.buildDirectory.file("generated/version/tvrenamer.version"))
    outputs.file(layout.buildDirectory.file("generated/version/tvrenamer.builddate"))
    outputs.file(layout.buildDirectory.file("generated/version/tvrenamer.commit"))
    doLast {
        def buildNumber = computeBuildNumber()
        def sha = computeCommitSha()
        def builtOn = computeBuildDateYYMMDDUtc()

        def outDir = layout.buildDirectory.dir("generated/version").get().asFile
        outDir.mkdirs()

        new File(outDir, "tvrenamer.version").text = "1.0.${buildNumber}\n"
        new File(outDir, "tvrenamer.builddate").text = "${builtOn}\n"
        new File(outDir, "tvrenamer.commit").text = "${sha}\n"
    }
}

def generatedVersionFile = layout.buildDirectory.file("generated/version/tvrenamer.version")
def generatedBuildDateFile = layout.buildDirectory.file("generated/version/tvrenamer.builddate")
def generatedCommitFile = layout.buildDirectory.file("generated/version/tvrenamer.commit")

tasks.named('processResources') {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    // Ensure generated build metadata replaces any static resources.
    exclude("tvrenamer.version")
    exclude("tvrenamer.builddate")
    exclude("tvrenamer.commit")

    dependsOn(tasks.named('generateBuildMetadataFiles'))

    // Add the generated metadata files into the root of the resources output.
    from(generatedVersionFile) {
        into ""
        rename { "tvrenamer.version" }
    }
    from(generatedBuildDateFile) {
        into ""
        rename { "tvrenamer.builddate" }
    }
    from(generatedCommitFile) {
        into ""
        rename { "tvrenamer.commit" }
    }

    // Workaround: ensure the files are present in build/resources/main even if Gradle's
    // CopySpec input isn't picked up as expected on some environments.
    doLast {
        copy {
            from(generatedVersionFile)
            from(generatedBuildDateFile)
            from(generatedCommitFile)
            into(layout.buildDirectory.dir("resources/main").get().asFile)
        }
    }
}

tasks.named('processTestResources') {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    // Tests also need build metadata on the classpath to avoid static init failures.
    // Ensure we use the generated metadata and do not rely on any source files.
    exclude("tvrenamer.version")
    exclude("tvrenamer.builddate")
    exclude("tvrenamer.commit")

    dependsOn(tasks.named('generateBuildMetadataFiles'))

    from(generatedVersionFile) {
        into ""
        rename { "tvrenamer.version" }
    }
    from(generatedBuildDateFile) {
        into ""
        rename { "tvrenamer.builddate" }
    }
    from(generatedCommitFile) {
        into ""
        rename { "tvrenamer.commit" }
    }

    // Workaround: ensure the files are present in build/resources/test even if Gradle's
    // CopySpec input isn't picked up as expected on some environments.
    doLast {
        copy {
            from(generatedVersionFile)
            from(generatedBuildDateFile)
            from(generatedCommitFile)
            into(layout.buildDirectory.dir("resources/test").get().asFile)
        }
    }
}

// Shadow plugin configuration for integrated JAR with all dependencies
shadowJar {
    // Keep the default classifier (typically "-all") stable so consumers
    // and CI artifact paths donâ€™t accidentally break.
    archiveClassifier.set('all')
    mergeServiceFiles()

    dependsOn(tasks.named('generateBuildMetadataFiles'))

    // Force the generated build metadata files into the JAR root.
    from(layout.buildDirectory.file("generated/version/tvrenamer.version")) {
        into ""
        rename { "tvrenamer.version" }
    }
    from(layout.buildDirectory.file("generated/version/tvrenamer.builddate")) {
        into ""
        rename { "tvrenamer.builddate" }
    }
    from(layout.buildDirectory.file("generated/version/tvrenamer.commit")) {
        into ""
        rename { "tvrenamer.commit" }
    }
}

sourceSets {
    main {
        java {
            srcDir 'src/main/java'
        }
        resources {
            srcDir 'src/main/resources'
        }
    }
    test {
        java {
            srcDir 'src/test/java'
            exclude 'org/tvrenamer/controller/TheTVDBProviderTest.java'
        }
        resources {
            srcDir 'src/test/resources'
        }
    }
    // Integration tests (TVDB / network-dependent). Not run as part of the standard 'test' task.
    integrationTest {
        java {
            // Reuse the same test sources, but only include the TVDB integration test.
            srcDir 'src/test/java'
            include 'org/tvrenamer/controller/TheTVDBProviderTest.java'
        }
        resources {
            srcDir 'src/test/resources'
        }

        // IMPORTANT: include the normal test outputs (e.g., EpisodeTestData) on the integration test classpath.
        compileClasspath += sourceSets.main.output + sourceSets.test.output + configurations.testRuntimeClasspath
        runtimeClasspath += output + compileClasspath
    }
}

configurations {
    integrationTestImplementation.extendsFrom(testImplementation)
    integrationTestRuntimeOnly.extendsFrom(testRuntimeOnly)
}

tasks.register('integrationTest', Test) {
    description = 'Runs network-dependent integration tests (TVDB).'
    group = 'verification'
    testClassesDirs = sourceSets.integrationTest.output.classesDirs
    classpath = sourceSets.integrationTest.runtimeClasspath
    shouldRunAfter(tasks.named('test'))
}

tasks.named('check') {
    dependsOn(tasks.named('test'))
    // integrationTest is opt-in; do not depend on it by default.
}

tasks.named('jar') {
    enabled = false
}

tasks.named('createExe') {
    dependsOn(tasks.named('shadowJar'))
}
